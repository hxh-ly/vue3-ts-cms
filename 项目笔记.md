## axios封装

1.axios封装成类

```js
import axios from 'axios'
import { AxiosInstance, AxiosRequestConfig } from 'axios'
class xhRequest{
    instance: AxiosInstance
    constructor(config:AxiosRequestConfig){
        this.instance=axios.create(config)
    }
	request(config:AxiosRequestConfig):void{
        this.instance.request(config).then(res=>{
            console.log(res)
        })
    }
}
```

2.添加拦截器

```js
type.ts
//
在拦截器传入的属性的类叫什么 ：  config

import { AxiosRequestConfig, AxiosResponse } from 'axios'
class HXHRequestInterceptor {
  requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig
  requestInterceptorCatch?: (err: any) => any
  resInterceptor?: (config: AxiosResponse) => AxiosResponse
  resInterceptorCatch?: (err: any) => any
}
//在原有的配置上加给属性interceptors【hooks】
interface HXHRequestConfig extends AxiosRequestConfig {
  interceptors?: HXHRequestInterceptor
}
export {
  HXHRequestInterceptor,
  HXHRequestConfig
}

```

```js
import axios from 'axios'
import { AxiosInstance, AxiosRequestConfig } from 'axios'
import { HXHRequestInterceptor, HXHRequestConfig } from './type'
class HXHRequest {
  instance: AxiosInstance
  interceptors?: HXHRequestInterceptor
  constructor(config: HXHRequestConfig) {
    this.instance = axios.create(config)
    this.interceptors = config.interceptors
    //请求的拦截
    this.instance.interceptors.request.use(
      this.interceptors?.requestInterceptor,
      this.interceptors?.requestInterceptorCatch
    )
    //响应的拦截
    this.instance.interceptors.response.use(
      this.interceptors?.resInterceptor,
      this.interceptors?.resInterceptorCatch
    )
  }
  request(config: AxiosRequestConfig): void {
    this.instance.request(config).then((res) => {
      console.log(res)
    })
  }
}

export default HXHRequest
```

3.全局拦截

```js
 constructor(config: HXHRequestConfig) {
    ++ this.instance.interceptors.request.use((config)=>{'全局请求拦截'})
    ++ this.instance.interceptors.response.use((config)=>{'全局响应拦截'}) 
  }
```

4.每个请求的控制  细粒度

```js
request(config:HXHRequestConfig):void{
  
   ++  if (config.interceptors?.requestInterceptor) {
   ++  config = config.interceptors.requestInterceptor(config)
   ++ }
    this.instance.request(config).then((res) => {
       
     ++  if (config.interceptors?.resInterceptor) {
     ++   res = config.interceptors.resInterceptor(res)
     ++   console.log(res)
      }
    })
  }
 
}
```

5.全局加loading

```js
class HXHRequest {

	++  isShowLoading: boolean
 	++  loading?: ILoadingInstance
  constructor(config: HXHRequestConfig) {
   
   	++ this.isShowLoading = config.isShowLoading ?? DEFAULT_LOADING
   
    this.instance.interceptors.request.use((config) => {
      // 全局请求加上loading
    ++ if (this.isShowLoading) {
        this.loading = ElLoading.service({
          lock: true,
          text: '请求中...',
          background: 'rgba(0,0,0,.5)'
        })
      }
      console.log('全局请求拦截+loading')
      return config
    })
    this.instance.interceptors.response.use((config) => {
      console.log('全局响应拦截-loading')
      //取消loading
      setTimeout(() => {
     ++   this.loading?.close()
      }, 1000)
      return config
    })
  }
  request<T>(config: HXHRequestConfig): Promise<T> {
      
     ++  if (config.isShowLoading === false) {
        this.isShowLoading = config.isShowLoading
      }  
 	 ++	this.instance.request<any, T>(config).then((res) => {
        resolve(res)
        this.isShowLoading = DEFAULT_LOADING
        })
  }
}
```

6.单独请求类型不匹配问题

```js
拓展 type.ts中
//待传入
class HXHRequestInterceptor<T = AxiosResponse> {
  requestInterceptor?: (config: AxiosRequestConfig) => AxiosRequestConfig
  requestInterceptorCatch?: (err: any) => any
  resInterceptor?: (config: T) => T
  resInterceptorCatch?: (err: any) => any
}

// 扩展类型
interface HXHRequestConfig<T= AxiosResponse> extends AxiosRequestConfig {
  interceptors?<T>: HXHRequestInterceptor
}
```

![image-20211128221219504](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211128221219504.png)



## tsconfig.json

```js
{
    "compilerOptions":{
		//目标代码 es5 |6 | 7
        "target":"esnext",
        //目标代码需要使用的模块化
        "module":"umd",
         //严格检查
        "strict":true,
        //对jsx进行怎么样的处理
         "jsx":"preserve"
        //辅助的导入功能
        "importHelpers":true,
         //node方式解析模块   
        "moduleResolution":"node",
		//跳过一些库的类型检查
        "skipLibCheck":true，
        // es module 和 commonjs
        "esModuleInterop":true,
        "allowSyntheticDefaultImports":true,
        "sourceMap":true,
        //基于当前文件    
        "baseUrl":".",
        //指定具体要解析使用的类型
        "types":["webpack-env"],
        //路径解析
        "paths":{
           "@/*":"src/*",
   		    "components/*":['src/components/*']            
        },
         // 可以指定在项目中可以使用哪些库的类型(proxy,window,document)   
        "lib":['esnext','dom','dom.iterable','scripthost']    
    },
  "include":[
      "src/**/*.ts",
      "src/**/*.tsx",
      "src/**/*,vue",
      "tests/**/*.ts",
      "tests/**/*.tsx"
  ],
    "exclude":['node_modules']
}
```

## shims

```js
//垫片  ts默认不认识 (vue.png ...)
declare  module '*.vue' {
    //组件类型
   import {DefineComponent} from 'vue' 
   const component:DefineComponent<{},{},any>
    //导出一个个DefineComponent对象
   export component    
}

//defineComponent的作用 
//函数传入很多泛型，对传入的对象进行默认类型推导，对于js是没有用，但对于ts可以做类型检查
export default definecomponent({
    props:{},
    setup(props){}
})
```

## css初始化

```js
npm install normalize.css

--assets
  --css
    --base.less
    --index.less
  --img
  
三种组件  通用性  cmps < components < base-ul  
```

# 登录

## 登录界面基本结构

```js
--src
  --views
    --login
      --cmps
        --login-panel.vue [使用element组件]
		--login-account.vue
	    --login-phone.vue
      --login.vue 
```

## 登录界面逻辑

```js
//login-account 账号登录组件 登录逻辑实现写在这个组件内，立即登录主要是派发事件

```

![image-20211201213506674](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211201213506674.png)

instanceType详解  【用来获取构造函数的返回类型】

```
// **.vue
export deafult definecomponent({ }) 导出的是一个组件的描述| 拥有构造函数实例

// 
	ref<instanceType <typeof **>>()
	
	
class People {
  name: string
  age: number

  constructor(name: string) {
    this.name = name;
  }
}
获取构造函数的返回类型
type IType = InstanceType<typeof People>
// type IType = People
// 因为constructor默认返回this
// constructor People(name: string): People	
```

## 记住密码和本地缓存

![image-20211202000721503](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211202000721503.png)

## login模块的创建

```
登录的其他操作
1.网络请求 拿到token userInfo
2 数据保存到某一个位置
3 发送其他请求（拿当前用户的信息）
4 用户菜单
5 跳转首页
```

## vuex使用

### 全局store

```js
vuex 分模块
传入<T>类型
import { login } from './login/login'
import { IRootStore } from './type'
const store = createStore<IRootStore>({
  state: () => {
    return {
      name: 'hxh',
      age: 'asda'
    }
  },
  mutations: {},
  actions: {},
  modules: {
    login
  }
})
```

```js
//全局store的type文件
interface ILoginStore {
  token: string
  userInfo: any
}
export { ILoginStore }
```

### login模块

```js
//login的type
interface ILoginStore {
  token: string
  userInfo: any
}
export { ILoginStore }
```

```js
import { Module } from 'vuex'
import { IRootStore } from '../type'
import { ILoginStore } from './type'
const login: Module<ILoginStore, IRootStore> = {
  namespaced: true,
  state: () => {
    return {
      token: 'aa',
      userInfo: 'asdas'
    }
  },
  actions: {
    accountLoginAction({ commit }, playload: any) {
      console.log('执行accountLoginAction', playload)
    }
  },
  mutations: {}
}
export { login }
```

```js
手机登录
1 判断在哪个tabs,
2 组件实例  ref='phoneRef'
3 调用loginAction.vue中, store.dispatch('login/phoneLoginAction')
```

```
登录接口
service
   --login
   	 --login.ts
   	 -- type.ts
   	 
store
   --login
      --login.ts
      --type.ts
      
1.返回{code,data}
2.post<T>
3.服务器返回结果加类型：IDataType<T=any>和data的类型:IloginResult
4.token放在Vuex里
```

```js
2 请求用户信息
enum LoginApi {
LoginUserInfo= '/users/'
}
export function requestUserInfoById(id:number){}



store调用,返回数据要不要建立javaBean的模型

保存在localCache

请求里记得携带toekn，在axios里

Vuex保存userInfo
```

```js
3 请求用户菜单
enum LoginApi {
UserMenus= '/role/'
}
export function requestUserMenusRoleId(id:number)
```

```js
4 跳转首页
router.push('/main')
//1 路由守卫
router.beforeEach(to) 
{ if(to!=='login') {
	if(!token) {return '/login'}
}
}
//2 遇到刷新，在main里要调setupStore()
function setupStore(){
//每次加载本地数据
store.dispatch('login/loadLocalLogin')
}
loginStore 将store的内容存到vuex里
//4 在app中要有 router-view
```

## 后台首页布局

![image-20211207232436793](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211207232436793.png)

目录

```
---components
   --nav-header
     --src
       --nav-menu.vue
     --index.ts (导出组件)  
     
   --nav-menu   
```

vuex在ts使用的小技巧

```js
pinia

// 1 自己封装useStore

//2  store可能有模块login
 IStoreType= IRootState & IRootWithModule

```

菜单列表渲染

![image-20211208213740973](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211208213740973.png)

首页菜单的相关属性

菜单的折叠和展开切换

![image-20211208225423840](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211208225423840.png)

# 权限管理和菜单动态路由

![image-20211208233125025](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211208233125025.png)

## 首页页面和路由对象的创建

```
//router和view试图的映射关系

--router
 --main
   --role
   
--views
  --main
    --role
    
    
//工具 自动建立对应的文件夹和映射关系
npm install coderwhy -g

coderwhy add3page user -d src/views/main/system/user
```



## 首页-菜单映射路由函数-加载所有的路由

```js
//1 util工具函数 map-menu
require.context('../router/main',true,/\.ts/) //获取上下文
// 全部路径
forEach( i=> allRoutes.push(require('../router/main')) )
//2 获取菜单对应路径
// 遍历菜单递归加入到routes 
//3 返回
```

## 首页-用户菜单和动态路由映射完成



## 首页-用户头像和名称的展示



用户页-搜索框和基本的搭建



用户页-HyForm的基本封装



## 用户页-HyForm的其他封装和配置文件

```js
 // user.vue 
<xh-form v-bind="searchFormConfig"></xh-form>
```

```js
 // search.config.ts  文件只需要配出来
 searchFormConfig:IForm = {
    labelWidth:
     formItem:
     itemStyle:
     colLayout:
 }
```

```js
 // form.ts  
```

## 页面刷新路由匹配的bug处理

```js
// 原理：
// 刷新重新执行 use ---> install --> 查找对应的路由 --> not-found ---> 注册入路由
// 跳转前   路由是注册了  但是to已经匹配上not-found

//解决  
setupStore()
app.use(router)
```

## 路径选中和菜单选中的映射关系

```
//1 路径
//2 菜单menu
//3 id

//Q:如果直接在 http://localhost:8080/是没有路径的 
//A：拿到第一条菜单, 从main重定向到第一条菜单
```

## 路径和面包屑显示的匹配

```js
//breadcrumb.vue
//1 拿到菜单
//2 util函数：
const breadcrumbs:IBreadcrumbs[]= pathMapBreadcrumbs(菜单，当前路由)
//3 template渲染
```

```tsx
breadcrumb/index.ts

import XhBreadcrumb from './src/breadcrumb.vue'
export * from './type'
export default XhBreadcrumb
```

```ts
//util 
//多加一个参数push到 IBreadcrumbs[]里面
export function pathMapBreadcrumbs(useMenus: any[], currentPath: string): any {
  const Breadcrumbs: IBreadcrumbs[] = []
  pathToMenu(useMenus, currentPath, Breadcrumbs)
  return Breadcrumbs
}
```

## HyForm实现双向绑定的方案

```js
//方案1:   违反单项数据流 在user（子）里修改form（父）
//user.vue
const formData=reative({
    id:'',
    name:''
})
配置文件里需要添加field字段，才有一一对应的关系
//form.vue
props:{
   formData
}
<el-input v-model="formData[`${item.id}`]" />   
```

```js
//方案2   等同于直接使用modelValue
<Xh-from   modelValue='formData' />
//user.vue
    
    
//form.vue    
 props:{
 modelValue:{
     type:Object,
     require:true
 }    
 }, 
 emits:['update:modelValue']    
//用formData去渲染，而不是modelValue去渲染
const formData = computed ({
  get:()=> props.modelValue, //看似没有直接使用modelValue
  //v-model 没触发set
  set:(newValue)=>{
      emit('update:modelValue',newValue)
  }
})    
```

```js
//方案3
//user.vue
<Xh-from   v-model='formData' />
const formData = ref({
    id:'',
    name:''
})

//form.vue
//1 拷贝modelValue
const formData = ref( {...props.modelValue } )
watch(formData,(newVal)=>{emit('update:modelValue')},{deep:true})
```

## HyForm插槽和PageSearch封装

```js
//本小节主要将hyfrom从user.vue 抽离出去成page-search组件
//加入插槽，props传值等
```

## User数据的获取和Store中的保存

```tsx
//创建system模块
//在store/index.ts 注册
---system
   --system.ts
   --types.ts 


---store/type.ts 
interface IRootWithModule {
  login: ILoginState
  system: ISystemState
}
```



```js
//步骤
1 user.vue调用dispatch('system/getPageListAction',
   { pageUrl,queryInfo}   ) 

2.在system模块中
 action:{
//网络请求
 }
 mutations:{
 //保存到数据到模块中    
 }
```

## ElTable展示数据和HyTabel封装

```js
--base-ui
  --table
    --src
    --index.ts

//user.vue
<div class='container'> <xh-table ></div>

//提供数据 
const userList = computed(() => store.state.system.userPageList)
 const propList = [
      { prop: 'name', label: '用户名', minWidth: '100' },
      { prop: 'realname', label: '真实性名', minWidth: '100' },
      { prop: 'cellphone', label: '手机号码', minWidth: '100' },
      { prop: 'enable', label: '状态', minWidth: '100' },
      { prop: 'createAt', label: '创建时间', minWidth: '250' },
      { prop: 'updateAt', label: '更新时间', minWidth: '250' }
    ]
//传入去组件 xh-table.vue

 <el-table :data=''>
	  <template v-for="item in proplist" :key="item.prop">
        <el-table-column align="center" v-bind="item" />
      </template>
 </el-table>
```

## HyTable的动态插槽和作用域插槽

```js
//本小节：如何修改table想要显示btn等
```

```html
<el-table-column align="center" v-bind="item">
    //默认的插槽
    //scope.row取到这一行的数据
          <template #default="scope">
            <slot>{{ scope.row[`${item.prop}`] }}</slot>
          </template>
   </el-table-column>
```

```html
//内层注意事项
//1动态给插槽设置名字
 <el-table-column align="center" v-bind="item">
          <template #default="scope">
            <slot :name="item.slotName"></slot>
          </template>
        </el-table-column>
//2插槽不需要修改的地方要有个默认名字
<el-table-column align="center" v-bind="item">
          <template #default="scope">
<slot :name="item.slotName">{{scope.row[`${item.prop}`]}} </slot>
          </template>
</el-table-column>

	
//外层 1需要对应到插槽名字（需要在加一个slotName字段）  2插入自己的修改
  <template #status="scope">
  <slot>
      <el-button>{{ scope.row.enable ? '启用' : '禁用' }}</el-button></slot>
  </template>

 <template #createAt="scope">
 <slot>
     <strong>{{ scope.row.createAt }}</strong>
    </slot>
 </template>
```

## 列表数据的优化和时间格式化

```js
//时间格式化
//方案：全局注册函数

// golbal/register-properties
app.config.globalProperties.$filters = {
  foo(){
      
  }
  formatTime(value:string) {
      return ''
// util使用dayjs封装格式化函数      
  }  
}
// golbal/register-element

// index.ts 
export default function registerGolbal(){}
```

## HyTable的选中-序号-操作列

```js
//isShowId字段 --> table属性
//isShowSelect字段 --> table属性
  table.vue
<el-table @selection-change='handleSelectChange'>
<el-table-column type='selection'>     
<el-table-column type='index'>     
</el-table>

//操作列 添加 {操作字段}
 const propList = [
 { prop: 'name', label: '用户名', minWidth: '100' },
 { prop: 'realname', label: '真实性名', minWidth: '100' },
 { prop: 'handle', label: '操作', minWidth: '140', slotName: 'handle' }
    ]
```

## HyTable的Header和Footer封装

```js
//本小结要实现
// slot name='header' 
// slot name='footer' 分页器
// 根组件  
<el-config-provider :locale="zh">  
 </el-config-provider>
```

![image-20211223224702674](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211223224702674.png)

## PageContent的配置和组件抽取

```js
//本小节
//1.将table抽取到pageContent通用组件里面
//2.将功能模块如:user.vue里面的网络请求也放在pageContent里 
//3.抽取user.vue的配置。传入到pageContent里面

//此后，开发页面最基础的只要传3个配置
//pageName
//searchConfig form的配置
//contentTabelConfig table的配置
```

![image-20211225135211066](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211225135211066.png)

## Vuex处理不同的页面数据

```js
//一、本小节
// 主要实现Vuex传入PageName 进行动态配置获取数据（userList,roleList ....）
// 配置role.vue页面
//二、 实现步骤
// 
getters:{
	pageListData(state) {
      return function (pageName: string) {
        return (state as any)[`${pageName}List`]
      }
    }
}

getPageListAction 方法（1.传入pageName 调各自的commit）
```

## pageSearch数据的二次处理

```js
//一、本小节
//实现搜索组件重置  当中涉及到数据的双向绑定
```

![image-20211225164036653](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211225164036653.png)

## 双向绑定的问题

```js
//方案1

```

```js
//方案2
不使用双向绑定
 <el-input
   :placeholder="item.placeholder"
    v-bind="item.otherOptions"
    :show-password="item.type === 'password'"
    :model-value="modelValue[`${item.field}`]"
	@update:modelvalue=' handleValueChange($event,item.field)'
    ></el-input>

//form.vue
handleValueChange(value:any,field:string) =>{
    emit('update:modelValue',{...props.modelValue,[field]:value})
}
//page-search.js
 handleResetClick=()=>{
     formData.value = formOriginData
 }

```

## 查询操作-根据条件查询结果

```js
//一、本小节
//1. 请求列表操作封装
//2. 抽出hook

//二、注意  + ref 组件
   <page-content ref="pageContentRef"> </page-content>
```

![image-20211225203058501](C:\Users\可爱的小栩\AppData\Roaming\Typora\typora-user-images\image-20211225203058501.png)

## 分页器

```js
//一、本小节


//二、步骤
//0  请求list的参数要动态的 
//1 pageContent.vue  vuex获取TotalCount 传到table
//2 pageContent.vue   v-model:page='pageInfo'  
//3 table     点击页数 发送事件 handleSizeChange 
//4 pageContent.vue      外面watch page 发送请求事件

   <el-pagination
          @size-change="handleSizeChange"  //
          @current-change="handleCurrentChange"
          :current-page="currentPage4"  //当前
          :page-sizes="[10, 20, 30, 40]"
          :page-size="100"
          layout="total, sizes, prev, pager, next, jumper"
          :total="400"
        >
        </el-pagination>
```

